

SysEndian =-1;--1:小端模式 2:大端模式
Endian =1;--强制使用的端排列顺序 1:小端模式 2:大端模式

function InitEndian()
	if( SysEndian==-1 ) then
		local str = "";
		str = str .. numToAscii(1);
		num = string.byte(str,1,1);
		if( num == 1 ) then
			SysEndian=1;
		else
			SysEndian=2;
		end
	end
end

--向指定的表中添加一个元素 序号自动加1 序号需要从1开始
function Proto_Table_Add(t,data)
    local index=#(t);
    t[index+1]=data;
end
--获取协议结构中table变量的元素量#(tbtest) t:传入的table变量 ，序号需要从1开始
function Proto_Table_Size(t)
	return #(t);
end

--获取协议结构中table变量的指定位置元素
function Proto_Table_Element(t,index)
	local size=#(t);
	if( index > size or index<1) then
		return nil;
	else
		return t[index];
	end
end

-- 左移
function leftShift(num, shift)
    return math.floor(num * (2 ^ shift));
end

-- 右移
function rightShift(num, shift)
    return math.floor(num / (2 ^ shift));
end
	
-- 转成Ascii
function numToAscii(num)
    num = num % 256;
    return string.char(num);
end

--二进制转boolean
function bufToBoolean(num1)
	if(num1 == 0)
	then
		return false
	else
	    return true
	end
end

-- 二进制转int64   endian_type:1:按照小端解析 2:按照大端解析
function bufToInt64(num1, num2, num3, num4,num5, num6, num7, num8,endian_type)
	if(endian_type==1) then
	    local num = 0;
		num = num + leftShift(num8, 56);
		num = num + leftShift(num7, 48);
		num = num + leftShift(num6, 40);
		num = num + leftShift(num5, 32);
		num = num + leftShift(num4, 24);
		num = num + leftShift(num3, 16);
		num = num + leftShift(num2, 8);
		num = num + num1;
		return num;
	elseif(endian_type==2) then
		local num = 0;
		num = num + leftShift(num1, 56);
		num = num + leftShift(num2, 48);
		num = num + leftShift(num3, 40);
		num = num + leftShift(num4, 32);
		num = num + leftShift(num5, 24);
		num = num + leftShift(num6, 16);
		num = num + leftShift(num7, 8);
		num = num + num8;
		return num;
	end
end

-- 二进制转int32   endian_type:1:按照小端解析 2:按照大端解析
function bufToInt32(num1, num2, num3, num4,endian_type)
	if(endian_type==1) then
		local num = 0;
		num = num + leftShift(num4, 24);
		num = num + leftShift(num3, 16);
		num = num + leftShift(num2, 8);
		num = num + num1;
		return num;
	elseif(endian_type==2) then
		local num = 0;
		num = num + leftShift(num1, 24);
		num = num + leftShift(num2, 16);
		num = num + leftShift(num3, 8);
		num = num + num4;
		return num;
	end
end

-- 二进制转int16   endian_type:1:按照小端解析 2:按照大端解析
function bufToInt16(num1, num2,endian_type)
	if(endian_type==1) then
	    local num = 0;
		num = num + leftShift(num2, 8);
		num = num + num1;
		return num;
	elseif(endian_type==2) then
		local num = 0;
		num = num + leftShift(num1, 8);
		num = num + num2;
		return num;
	end
end

-- bool转二进制
function booleanToBufStr(bl)
	local str = "";
	if(bl)
	then
		str=str..numToAscii(1);
	else
		str=str..numToAscii(0);
	end
	return str;
end

-- int64转二进制  endian_type:1:小端排序 2:大端排序
function int64ToBufStr(num,endian_type)
	if(endian_type==1) then
		local str = "";
		str = str .. numToAscii(num);
		str = str .. numToAscii(rightShift(num, 8));
		str = str .. numToAscii(rightShift(num, 16));
		str = str .. numToAscii(rightShift(num, 24));
		str = str .. numToAscii(rightShift(num, 32));
		str = str .. numToAscii(rightShift(num, 40));
		str = str .. numToAscii(rightShift(num, 48));
		str = str .. numToAscii(rightShift(num, 56));
		return str;
	elseif (endian_type==2) then
		local str = "";
		str = str .. numToAscii(rightShift(num, 56));
		str = str .. numToAscii(rightShift(num, 48));
		str = str .. numToAscii(rightShift(num, 40));
		str = str .. numToAscii(rightShift(num, 32));
		str = str .. numToAscii(rightShift(num, 24));
		str = str .. numToAscii(rightShift(num, 16));
		str = str .. numToAscii(rightShift(num, 8));
		str = str .. numToAscii(num);
		return str;
	end
end

-- int32转二进制  endian_type:1:小端排序 2:大端排序
function int32ToBufStr(num,endian_type)
	if(endian_type==1) then
		local str = "";
		str = str .. numToAscii(num);
		str = str .. numToAscii(rightShift(num, 8));
		str = str .. numToAscii(rightShift(num, 16));
		str = str .. numToAscii(rightShift(num, 24));
		return str;
	elseif (endian_type==2) then
		local str = "";
		str = str .. numToAscii(rightShift(num, 24));
		str = str .. numToAscii(rightShift(num, 16));
		str = str .. numToAscii(rightShift(num, 8));
		str = str .. numToAscii(num);
		return str;
	end
end

-- int16转二进制 endian_type:1:小端排序 2:大端排序
function int16ToBufStr(num,endian_type)
	if(endian_type==1) then
		local str = "";
		str = str .. numToAscii(num);
		str = str .. numToAscii(rightShift(num, 8));
		return str;
	elseif (endian_type==2) then
		local str = "";
		str = str .. numToAscii(rightShift(num, 8));
		str = str .. numToAscii(num);
		return str;
	end
end

--序列化普通变量 t:类型   1:int16 2:int32 3:int64 4:bool 5:string 返回数据总长度（包含头）和 二进制数据
function Serialize_Normal(val,t)
	local str = "";
	local str_size = "";
	local size = 0;
	local is_num=false;
	local minus=1;--正负标记 0：负数 1：正数
	if(t == 1 ) then --int16
	    is_num=true;
	    if(val<0) then
	        val=-val;
	        minus=0;
	    end
		str = int16ToBufStr(val,Endian); --根据端序进行大小端排序
		size = 2;
	elseif( t ==2 ) then--int32
	    is_num=true;
	    if(val<0) then
	        val=-val;
	        minus=0;
	    end
		str = int32ToBufStr(val,Endian);--根据端序进行大小端排序
		size = 4;
	elseif( t == 3 ) then--int64
	    is_num=true;
	    if(val<0) then
	        val=-val;
	        minus=0;
	    end
		str = int64ToBufStr(val,Endian);--根据端序进行大小端排序
		size = 8;
	elseif( t == 4 ) then--bool
	    is_num=true;
		str = booleanToBufStr(val);
		size = 1;
	elseif( t == 5 ) then--string
		str=val;
		if(str == nil) then
			str = "";
		end
		local strlen = string.len(str);
		str_size = int32ToBufStr(strlen,Endian);--根据端序进行大小端排序
		size = strlen;
	end
	if(is_num) then
	    str_minus= int16ToBufStr(minus,Endian);--根据端序进行大小端排序
	    str_size = numToAscii(126)..int32ToBufStr(size+2,Endian)..numToAscii(126);--根据端序进行大小端排序
	    str = str_size..str_minus..str;
	    size = 6+size+2;
	    return size,str;
	else
	    str_size = numToAscii(126)..str_size..numToAscii(126);
	    str = str_size..str;
	    size = 6+size;
	    return size,str;
	end
end

--序列化普通变量 列表 t:类型   1:int16 2:int32 3:int64 4:bool 5:string 返回数据总长度（包含头）和 二进制数据
function Serialize_Normal_List(val,t)
	local size_all=0;
	local str = "";
	for k, v in ipairs(val) do 
		local size,res = Serialize_Normal(v,t);
		size_all = size_all+size;
		str = str..res;
	end
	local str_size=numToAscii(94)..int32ToBufStr(size_all,Endian)..numToAscii(94);--根据端序进行大小端排序
    str=str_size..str;
	size_all=size_all+6;
	--print("尺寸:"..size_all);
	--print(string.byte(str,1,size_all));
	return size_all,str;
end

--序列化自定义变量 返回数据总长度（包含头）和 二进制数据
function Serialize_Self(val)
	local size,str=val.Serialize(val);
	local size_buf="";
	return size,str;
end

--序列化自定义变量列表 返回数据总长度（包含头）和 二进制数据
function Serialize_Self_list(val)
	local size=0;
	local str="";
	for k, v in ipairs(val) do 
		local size_e,res_e = Serialize_Self(v);
		size = size+size_e;
		str = str..res_e;
	end
	local str_size=numToAscii(94)..int32ToBufStr(size,Endian)..numToAscii(94);--根据端序进行大小端排序
	str=str_size..str;
	size=size+6;
	return size,str;
end
 
--反序列化普通变量 单 t:类型 target_endian:接收服务端的大小端排序   1:int16 2:int32 3:int64 4:bool 5:string 返回 处理的字节数，结果数据，  剩余字符串
function Deserialize_Normal(str,t,target_endian)
    --print("反序列化PT_1：",string.byte(str,1,string.len(str)));
	if( str == nil or string.byte(str,1,1) ~= 126 ) then
		print("反序列化普通变量失败nil");
		return 0,nil,nil;
	end
	local size_str=string.sub(str,2,5);
	local n1,n2,n3,n4=string.byte(size_str,1,4);
	local size=bufToInt32(n1,n2,n3,n4,target_endian);--根据接收端的大小端进行排序
	if( size > string.len(str)-6 ) then
		print("反序列化普通变量失败size");
		return 0,nil,nil;
	end
	local res_str;--剩下的字符串
	
	if( (6+size)<=string.len(str))  then
		res_str=string.sub(str,6+size+1,string.len(str));
	else
		res_str=nil;
	end
	--print("反序列化PT_2：",string.byte(res_str,1,string.len(res_str)));
	--
	if(size==0) then
		if(t == 1 ) then --int16
			return 6,0,res_str;
		elseif( t ==2 ) then--int32
			return 6,0,res_str;
		elseif( t == 3 ) then--int64
			return 6,0,res_str;
		elseif( t == 4 ) then--bool
			return 6,false,res_str;
		elseif( t == 5 ) then--string
			local r_n= "";
			return 6,r_n,res_str;
		end
	end
	--
	if(t == 1 ) then --int16
		local minus_str=string.sub(str,7,8);--正负标记
		local n1,n2=string.byte(minus_str,1,2);
		local minus= bufToInt16(n1,n2,target_endian);--根据接收端的大小端进行排序
		if(minus==0) then
		    minus=-1;
		end
		local num_str=string.sub(str,9,10);
		n1,n2=string.byte(num_str,1,2);
		return size+6,bufToInt16(n1,n2,target_endian)*minus,res_str;--根据接收端的大小端进行排序
	elseif( t ==2 ) then--int32
		local minus_str=string.sub(str,7,8);--正负标记
		local n1,n2=string.byte(minus_str,1,2);
		local minus= bufToInt16(n1,n2,target_endian);--根据接收端的大小端进行排序
		if(minus==0) then
		    minus=-1;
		end
		local num_str=string.sub(str,9,12);
		local num1,num2,num3,num4=string.byte(num_str,1,4);
		return size+6,bufToInt32(num1,num2,num3,num4,target_endian)*minus,res_str;--根据接收端的大小端进行排序
	elseif( t == 3 ) then--int64
		local minus_str=string.sub(str,7,8);--正负标记
		local n1,n2=string.byte(minus_str,1,2);
		local minus= bufToInt16(n1,n2,target_endian);--根据接收端的大小端进行排序
		if(minus==0) then
		    minus=-1;
		end
		local num_str=string.sub(str,9,16);
		local num1,num2,num3,num4,num5,num6,num7,num8=string.byte(num_str,1,8);
		return size+6,bufToInt64(num1,num2,num3,num4,num5,num6,num7,num8,target_endian)*minus,res_str;--根据接收端的大小端进行排序
	elseif( t == 4 ) then--bool
		local num_str=string.sub(str,9,9);
		local num=string.byte(num_str,1,1);
		return size+6,bufToBoolean(num),res_str;
	elseif( t == 5 ) then--string
		local num_str=string.sub(str,7,size+6);
		return size+6,string.char(string.byte(num_str,1,size)),res_str;
	end
end

--反序列化普通变量 列表 t:类型   1:int16 2:int32 3:int64 4:bool 5:string 处理的字节数,返回剩余字符串
function Deserialize_Normal_List(str , t,target_endian)
	--print("反序列化PTList_1：",string.byte(str,1,string.len(str)));
	tabel_target={};
	if( str == nil or string.byte(str,1,1) ~= 94 ) then
		print("反序列化普通变量列表失败nil");
		return tabel_target,0,nil;
	end
	local size_str=string.sub(str,2,5);
	local num1,num2,num3,num4=string.byte(size_str,1,4);
	local size=bufToInt32(num1,num2,num3,num4,target_endian);--根据接收端的大小端进行排序
	if( size > string.len(str)-6 ) then
		print("反序列化普通变量列表失败size");
		return tabel_target,0,nil;
	end
	--
	local res_str;--剩下的字符串
	if( (6+size)<=string.len(str))  then
		res_str=string.sub(str,6+size+1,string.len(str));
	else
	    
		res_str=nil;
	end
	--print("反序列化PTList_2：",string.byte(res_str,1,string.len(res_str)));
	--
	if(size==0) then
		return tabel_target,6,res_str;
	end
	local table_i=1;
	local index=7;
	local c_str=string.sub(str,7,7+size-1);
	local c_size=0;
	local c_res=0;
	
	while ( index<size ) do
		c_size,c_res,c_str=Deserialize_Normal(c_str,t,target_endian);
		if(c_res == nil) then
			print("反序列化普通变量列表失败while nil");
			return tabel_target,nil,nil;
		else
			
			tabel_target[table_i]=c_res;
			table_i=table_i+1;
			index=index+c_size;
		end
	end
	return tabel_target,6+size,res_str;
end

--反序列化自定义变量 单 返回 处理的字节数，剩余字符串
function Deserialize_Self(str,target_val,target_endian)
    --print("反序列化Self_1：",string.byte(str,1,string.len(str)));
	local size=0;
	size,str=target_val.Deserialize(str,target_val,target_endian);
	--print("反序列化Self_2：",string.byte(str,1,string.len(str)));
	return size+6,str;
end

--反序列化自定义变量 列表 返回 结果表格，处理的字节数，剩余字符串
function Deserialize_Self_List(str,tb,target_endian)
    --print("反序列化SelfList_1：",string.byte(str,1,string.len(str)));
    target_val={};
	if( str == nil or string.byte(str,1,1) ~= 94 ) then
		print("反序列化自定义变量列表失败nil");
		return target_val,0,nil;
	end
	
	local size_str=string.sub(str,2,5);
	local num1,num2,num3,num4=string.byte(size_str,1,4);
	local size=bufToInt32(num1,num2,num3,num4,target_endian);--根据接收端的大小端进行排序
	if( size > string.len(str)-6 ) then
		print("反序列化自定义变量列表失败size");
		return target_val,0,nil;
	end
	--
	local res_str;--剩下的字符串
	if( (6+size)<=string.len(str))  then
		res_str=string.sub(str,6+size+1,string.len(str));
	else
		res_str=nil;
	end
	--print("反序列化SelfList_2：",string.byte(res_str,1,string.len(res_str)));
	--
	if(size==0) then
		return target_val,6,res_str;
	end
	local table_i=1;
	local c_str=string.sub(str,7,7+size-1);
	local c_size=0;
	local c_res=0;
	
	while ( size>0 ) do
		new_data=tb.new();
		c_size,c_str=Deserialize_Self(c_str,new_data,target_endian);
		if(c_res == nil) then
			print("反序列化普通变量列表失败while nil");
			return target_val,nil,nil;
		else
			target_val[table_i]=new_data;
			table_i=table_i+1;
			size=size-c_size;
		end
	end
	return target_val,c_size+6,res_str;
end
